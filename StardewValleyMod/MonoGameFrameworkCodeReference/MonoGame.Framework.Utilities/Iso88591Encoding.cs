using System.Collections.Generic;
using System.Text;

namespace MonoGame.Framework.Utilities;

/// <summary>
/// A custom encoding class that provides encoding capabilities for the
/// 'Western European (ISO)' encoding under Silverlight.<br />
/// This class was generated by a tool. For more information, visit
/// http://www.hardcodet.net/2010/03/silverlight-text-encoding-class-generator
/// </summary>
internal class Iso88591Encoding : Encoding
{
	private char? fallbackCharacter;

	/// <summary>
	/// This table contains characters in an array. The index within the
	/// array corresponds to the encoding's mapping of bytes to characters
	/// (e.g. if a byte value of 5 is used to encode the character 'x', this
	/// character will be stored at the array index 5.
	/// </summary>
	private static char[] byteToChar = new char[256]
	{
		'\0', '\u0001', '\u0002', '\u0003', '\u0004', '\u0005', '\u0006', '\a', '\b', '\t',
		'\n', '\v', '\f', '\r', '\u000e', '\u000f', '\u0010', '\u0011', '\u0012', '\u0013',
		'\u0014', '\u0015', '\u0016', '\u0017', '\u0018', '\u0019', '\u001a', '\u001b', '\u001c', '\u001d',
		'\u001e', '\u001f', ' ', '!', '"', '#', '$', '%', '&', '\'',
		'(', ')', '*', '+', ',', '-', '.', '/', '0', '1',
		'2', '3', '4', '5', '6', '7', '8', '9', ':', ';',
		'<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E',
		'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
		'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
		'Z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c',
		'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
		'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
		'x', 'y', 'z', '{', '|', '}', '~', '\u007f', '\u0080', '\u0081',
		'\u0082', '\u0083', '\u0084', '\u0085', '\u0086', '\u0087', '\u0088', '\u0089', '\u008a', '\u008b',
		'\u008c', '\u008d', '\u008e', '\u008f', '\u0090', '\u0091', '\u0092', '\u0093', '\u0094', '\u0095',
		'\u0096', '\u0097', '\u0098', '\u0099', '\u009a', '\u009b', '\u009c', '\u009d', '\u009e', '\u009f',
		'\u00a0', '¡', '¢', '£', '¤', '¥', '¦', '§', '\u00a8', '©',
		'ª', '«', '¬', '\u00ad', '®', '\u00af', '°', '±', '²', '³',
		'\u00b4', 'µ', '¶', '·', '\u00b8', '¹', 'º', '»', '¼', '½',
		'¾', '¿', 'À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ', 'Ç',
		'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ð', 'Ñ',
		'Ò', 'Ó', 'Ô', 'Õ', 'Ö', '×', 'Ø', 'Ù', 'Ú', 'Û',
		'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'â', 'ã', 'ä', 'å',
		'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï',
		'ð', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', '÷', 'ø', 'ù',
		'ú', 'û', 'ü', 'ý', 'þ', 'ÿ'
	};

	/// <summary>
	/// This dictionary is used to resolve byte values for a given character.
	/// </summary>
	private static Dictionary<char, byte> charToByte = new Dictionary<char, byte>
	{
		{ '\0', 0 },
		{ '\u0001', 1 },
		{ '\u0002', 2 },
		{ '\u0003', 3 },
		{ '\u0004', 4 },
		{ '\u0005', 5 },
		{ '\u0006', 6 },
		{ '\a', 7 },
		{ '\b', 8 },
		{ '\t', 9 },
		{ '\n', 10 },
		{ '\v', 11 },
		{ '\f', 12 },
		{ '\r', 13 },
		{ '\u000e', 14 },
		{ '\u000f', 15 },
		{ '\u0010', 16 },
		{ '\u0011', 17 },
		{ '\u0012', 18 },
		{ '\u0013', 19 },
		{ '\u0014', 20 },
		{ '\u0015', 21 },
		{ '\u0016', 22 },
		{ '\u0017', 23 },
		{ '\u0018', 24 },
		{ '\u0019', 25 },
		{ '\u001a', 26 },
		{ '\u001b', 27 },
		{ '\u001c', 28 },
		{ '\u001d', 29 },
		{ '\u001e', 30 },
		{ '\u001f', 31 },
		{ ' ', 32 },
		{ '!', 33 },
		{ '"', 34 },
		{ '#', 35 },
		{ '$', 36 },
		{ '%', 37 },
		{ '&', 38 },
		{ '\'', 39 },
		{ '(', 40 },
		{ ')', 41 },
		{ '*', 42 },
		{ '+', 43 },
		{ ',', 44 },
		{ '-', 45 },
		{ '.', 46 },
		{ '/', 47 },
		{ '0', 48 },
		{ '1', 49 },
		{ '2', 50 },
		{ '3', 51 },
		{ '4', 52 },
		{ '5', 53 },
		{ '6', 54 },
		{ '7', 55 },
		{ '8', 56 },
		{ '9', 57 },
		{ ':', 58 },
		{ ';', 59 },
		{ '<', 60 },
		{ '=', 61 },
		{ '>', 62 },
		{ '?', 63 },
		{ '@', 64 },
		{ 'A', 65 },
		{ 'B', 66 },
		{ 'C', 67 },
		{ 'D', 68 },
		{ 'E', 69 },
		{ 'F', 70 },
		{ 'G', 71 },
		{ 'H', 72 },
		{ 'I', 73 },
		{ 'J', 74 },
		{ 'K', 75 },
		{ 'L', 76 },
		{ 'M', 77 },
		{ 'N', 78 },
		{ 'O', 79 },
		{ 'P', 80 },
		{ 'Q', 81 },
		{ 'R', 82 },
		{ 'S', 83 },
		{ 'T', 84 },
		{ 'U', 85 },
		{ 'V', 86 },
		{ 'W', 87 },
		{ 'X', 88 },
		{ 'Y', 89 },
		{ 'Z', 90 },
		{ '[', 91 },
		{ '\\', 92 },
		{ ']', 93 },
		{ '^', 94 },
		{ '_', 95 },
		{ '`', 96 },
		{ 'a', 97 },
		{ 'b', 98 },
		{ 'c', 99 },
		{ 'd', 100 },
		{ 'e', 101 },
		{ 'f', 102 },
		{ 'g', 103 },
		{ 'h', 104 },
		{ 'i', 105 },
		{ 'j', 106 },
		{ 'k', 107 },
		{ 'l', 108 },
		{ 'm', 109 },
		{ 'n', 110 },
		{ 'o', 111 },
		{ 'p', 112 },
		{ 'q', 113 },
		{ 'r', 114 },
		{ 's', 115 },
		{ 't', 116 },
		{ 'u', 117 },
		{ 'v', 118 },
		{ 'w', 119 },
		{ 'x', 120 },
		{ 'y', 121 },
		{ 'z', 122 },
		{ '{', 123 },
		{ '|', 124 },
		{ '}', 125 },
		{ '~', 126 },
		{ '\u007f', 127 },
		{ '\u0080', 128 },
		{ '\u0081', 129 },
		{ '\u0082', 130 },
		{ '\u0083', 131 },
		{ '\u0084', 132 },
		{ '\u0085', 133 },
		{ '\u0086', 134 },
		{ '\u0087', 135 },
		{ '\u0088', 136 },
		{ '\u0089', 137 },
		{ '\u008a', 138 },
		{ '\u008b', 139 },
		{ '\u008c', 140 },
		{ '\u008d', 141 },
		{ '\u008e', 142 },
		{ '\u008f', 143 },
		{ '\u0090', 144 },
		{ '\u0091', 145 },
		{ '\u0092', 146 },
		{ '\u0093', 147 },
		{ '\u0094', 148 },
		{ '\u0095', 149 },
		{ '\u0096', 150 },
		{ '\u0097', 151 },
		{ '\u0098', 152 },
		{ '\u0099', 153 },
		{ '\u009a', 154 },
		{ '\u009b', 155 },
		{ '\u009c', 156 },
		{ '\u009d', 157 },
		{ '\u009e', 158 },
		{ '\u009f', 159 },
		{ '\u00a0', 160 },
		{ '¡', 161 },
		{ '¢', 162 },
		{ '£', 163 },
		{ '¤', 164 },
		{ '¥', 165 },
		{ '¦', 166 },
		{ '§', 167 },
		{ '\u00a8', 168 },
		{ '©', 169 },
		{ 'ª', 170 },
		{ '«', 171 },
		{ '¬', 172 },
		{ '\u00ad', 173 },
		{ '®', 174 },
		{ '\u00af', 175 },
		{ '°', 176 },
		{ '±', 177 },
		{ '²', 178 },
		{ '³', 179 },
		{ '\u00b4', 180 },
		{ 'µ', 181 },
		{ '¶', 182 },
		{ '·', 183 },
		{ '\u00b8', 184 },
		{ '¹', 185 },
		{ 'º', 186 },
		{ '»', 187 },
		{ '¼', 188 },
		{ '½', 189 },
		{ '¾', 190 },
		{ '¿', 191 },
		{ 'À', 192 },
		{ 'Á', 193 },
		{ 'Â', 194 },
		{ 'Ã', 195 },
		{ 'Ä', 196 },
		{ 'Å', 197 },
		{ 'Æ', 198 },
		{ 'Ç', 199 },
		{ 'È', 200 },
		{ 'É', 201 },
		{ 'Ê', 202 },
		{ 'Ë', 203 },
		{ 'Ì', 204 },
		{ 'Í', 205 },
		{ 'Î', 206 },
		{ 'Ï', 207 },
		{ 'Ð', 208 },
		{ 'Ñ', 209 },
		{ 'Ò', 210 },
		{ 'Ó', 211 },
		{ 'Ô', 212 },
		{ 'Õ', 213 },
		{ 'Ö', 214 },
		{ '×', 215 },
		{ 'Ø', 216 },
		{ 'Ù', 217 },
		{ 'Ú', 218 },
		{ 'Û', 219 },
		{ 'Ü', 220 },
		{ 'Ý', 221 },
		{ 'Þ', 222 },
		{ 'ß', 223 },
		{ 'à', 224 },
		{ 'á', 225 },
		{ 'â', 226 },
		{ 'ã', 227 },
		{ 'ä', 228 },
		{ 'å', 229 },
		{ 'æ', 230 },
		{ 'ç', 231 },
		{ 'è', 232 },
		{ 'é', 233 },
		{ 'ê', 234 },
		{ 'ë', 235 },
		{ 'ì', 236 },
		{ 'í', 237 },
		{ 'î', 238 },
		{ 'ï', 239 },
		{ 'ð', 240 },
		{ 'ñ', 241 },
		{ 'ò', 242 },
		{ 'ó', 243 },
		{ 'ô', 244 },
		{ 'õ', 245 },
		{ 'ö', 246 },
		{ '÷', 247 },
		{ 'ø', 248 },
		{ 'ù', 249 },
		{ 'ú', 250 },
		{ 'û', 251 },
		{ 'ü', 252 },
		{ 'ý', 253 },
		{ 'þ', 254 },
		{
			'ÿ',
			byte.MaxValue
		}
	};

	/// <summary>
	/// Gets the name registered with the
	/// Internet Assigned Numbers Authority (IANA) for the current encoding.
	/// </summary>
	/// <returns>
	/// The IANA name for the current <see cref="T:System.Text.Encoding" />.
	/// </returns>
	public override string WebName => "iso-8859-1";

	/// <summary>
	/// A character that can be set in order to make the encoding class
	/// more fault tolerant. If this property is set, the encoding class will
	/// use this property instead of throwing an exception if an unsupported
	/// byte value is being passed for decoding.
	/// </summary>
	public char? FallbackCharacter
	{
		get
		{
			return this.fallbackCharacter;
		}
		set
		{
			this.fallbackCharacter = value;
			if (value.HasValue && !Iso88591Encoding.charToByte.ContainsKey(value.Value))
			{
				throw new EncoderFallbackException($"Cannot use the character [{value.Value}] (int value {(int)value.Value}) as fallback value - the fallback character itself is not supported by the encoding.");
			}
			this.FallbackByte = (value.HasValue ? new byte?(Iso88591Encoding.charToByte[value.Value]) : ((byte?)null));
		}
	}

	/// <summary>
	/// A byte value that corresponds to the <see cref="P:MonoGame.Framework.Utilities.Iso88591Encoding.FallbackCharacter" />.
	/// It is used in encoding scenarios in case an unsupported character is
	/// being passed for encoding.
	/// </summary>
	public byte? FallbackByte { get; private set; }

	/// <summary>
	/// Gets the number of characters that are supported by this encoding.
	/// This property returns a maximum value of 256, as the encoding class
	/// only supports single byte encodings (1 byte == 256 possible values).
	/// </summary>
	public static int CharacterCount => Iso88591Encoding.byteToChar.Length;

	public Iso88591Encoding()
	{
		this.FallbackCharacter = '?';
	}

	/// <summary>
	/// Encodes a set of characters from the specified character array into the specified byte array.
	/// </summary>
	/// <returns>
	/// The actual number of bytes written into <paramref name="bytes" />.
	/// </returns>
	/// <param name="chars">The character array containing the set of characters to encode. 
	/// </param><param name="charIndex">The index of the first character to encode. 
	/// </param><param name="charCount">The number of characters to encode. 
	/// </param><param name="bytes">The byte array to contain the resulting sequence of bytes.
	/// </param><param name="byteIndex">The index at which to start writing the resulting sequence of bytes. 
	/// </param>
	public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
	{
		if (!this.FallbackByte.HasValue)
		{
			return this.GetBytesWithoutFallback(chars, charIndex, charCount, bytes, byteIndex);
		}
		return this.GetBytesWithFallBack(chars, charIndex, charCount, bytes, byteIndex);
	}

	private int GetBytesWithFallBack(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
	{
		for (int i = 0; i < charCount; i++)
		{
			char character = chars[i + charIndex];
			byte byteValue;
			bool status = Iso88591Encoding.charToByte.TryGetValue(character, out byteValue);
			bytes[byteIndex + i] = (status ? byteValue : this.FallbackByte.Value);
		}
		return charCount;
	}

	private int GetBytesWithoutFallback(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
	{
		for (int i = 0; i < charCount; i++)
		{
			char character = chars[i + charIndex];
			if (!Iso88591Encoding.charToByte.TryGetValue(character, out var byteValue))
			{
				throw new EncoderFallbackException($"The encoding [{this.WebName}] cannot encode the character [{character}] (int value {(int)character}). Set the FallbackCharacter property in order to suppress this exception and encode a default character instead.");
			}
			bytes[byteIndex + i] = byteValue;
		}
		return charCount;
	}

	/// <summary>
	/// Decodes a sequence of bytes from the specified byte array into the specified character array.
	/// </summary>
	/// <returns>
	/// The actual number of characters written into <paramref name="chars" />.
	/// </returns>
	/// <param name="bytes">The byte array containing the sequence of bytes to decode. 
	/// </param><param name="byteIndex">The index of the first byte to decode. 
	/// </param><param name="byteCount">The number of bytes to decode. 
	/// </param><param name="chars">The character array to contain the resulting set of characters. 
	/// </param><param name="charIndex">The index at which to start writing the resulting set of characters. 
	/// </param>
	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
	{
		if (!this.FallbackCharacter.HasValue)
		{
			return this.GetCharsWithoutFallback(bytes, byteIndex, byteCount, chars, charIndex);
		}
		return this.GetCharsWithFallback(bytes, byteIndex, byteCount, chars, charIndex);
	}

	private int GetCharsWithFallback(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
	{
		for (int i = 0; i < byteCount; i++)
		{
			byte lookupIndex = bytes[i + byteIndex];
			char result = ((lookupIndex >= Iso88591Encoding.byteToChar.Length) ? this.FallbackCharacter.Value : Iso88591Encoding.byteToChar[lookupIndex]);
			chars[charIndex + i] = result;
		}
		return byteCount;
	}

	private int GetCharsWithoutFallback(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
	{
		for (int i = 0; i < byteCount; i++)
		{
			byte lookupIndex = bytes[i + byteIndex];
			if (lookupIndex >= Iso88591Encoding.byteToChar.Length)
			{
				throw new EncoderFallbackException($"The encoding [{this.WebName}] cannot decode byte value [{lookupIndex}]. Set the FallbackCharacter property in order to suppress this exception and decode the value as a default character instead.");
			}
			chars[charIndex + i] = Iso88591Encoding.byteToChar[lookupIndex];
		}
		return byteCount;
	}

	/// <summary>
	/// Calculates the number of bytes produced by encoding a set of characters
	/// from the specified character array.
	/// </summary>
	/// <returns>
	/// The number of bytes produced by encoding the specified characters. This class
	/// always returns the value of <paramref name="count" />.
	/// </returns>
	public override int GetByteCount(char[] chars, int index, int count)
	{
		return count;
	}

	/// <summary>
	/// Calculates the number of characters produced by decoding a sequence
	/// of bytes from the specified byte array.
	/// </summary>
	/// <returns>
	/// The number of characters produced by decoding the specified sequence of bytes. This class
	/// always returns the value of <paramref name="count" />. 
	/// </returns>
	public override int GetCharCount(byte[] bytes, int index, int count)
	{
		return count;
	}

	/// <summary>
	/// Calculates the maximum number of bytes produced by encoding the specified number of characters.
	/// </summary>
	/// <returns>
	/// The maximum number of bytes produced by encoding the specified number of characters. This
	/// class always returns the value of <paramref name="charCount" />.
	/// </returns>
	/// <param name="charCount">The number of characters to encode. 
	/// </param>
	public override int GetMaxByteCount(int charCount)
	{
		return charCount;
	}

	/// <summary>
	/// Calculates the maximum number of characters produced by decoding the specified number of bytes.
	/// </summary>
	/// <returns>
	/// The maximum number of characters produced by decoding the specified number of bytes. This class
	/// always returns the value of <paramref name="byteCount" />.
	/// </returns>
	/// <param name="byteCount">The number of bytes to decode.</param> 
	public override int GetMaxCharCount(int byteCount)
	{
		return byteCount;
	}
}
